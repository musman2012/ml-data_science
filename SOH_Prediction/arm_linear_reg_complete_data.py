# -*- coding: utf-8 -*-
"""ARM_Linear_Reg_Complete_Data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VPVC0TAnr_7-hqMh8mLsB0VxWOKIyIAu

### Statistical Analysis of Battery Data
"""

import platform
import dill
dill.load_session('notebook_env.db')
platform.architecture()

#!pip install tensorflow==2.0.0-alpha0

# Commented out IPython magic to ensure Python compatibility.
'''
authored by Muhammad Usman (musman14@student.bradford.ac.uk)
!pip install pandas
!pip install numpy
!pip install matplotlib
!pip install seaborn
'''

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

FILE_PATH = "batteries_processed.csv"
bat_data = pd.read_csv(FILE_PATH, error_bad_lines = False)    # reading the data from csv file

data_columns = bat_data.columns

input_data = bat_data.copy()
columns_to_drop = ['id', 'vin', 'vin_prefix', 'record_id', 'actual_time', 'arrival_time', 'powermode', 'mheader_vin', 'mheader_time', 'mheader_type', 'message','cat4', 'cat6', 'cat7', 'inlet_coolant_temp','cooling_energy_used', 'max_soh_cell', 'power_soh', 'min_soh', 'max_soh', 'soh','min_soh_cell_id','imbalance_percent', 'parkingdata_hvbattavgsocoatevent', 'parkingdata_hvbattavtempatevent']
input_data = input_data.drop(columns=columns_to_drop)
input_data.head()

## keep vin_prefix for input variables
## min_voltage is highly correlated with traction voltage and max_voltage
##

"""# New Section"""

output_data = bat_data.soh

bat_data['balancing_status'].value_counts()
bat_data['balancing_status'].unique()

#!pip install sklearn
from sklearn.model_selection import train_test_split 
from sklearn.linear_model import LinearRegression
from sklearn import metrics

print(input_data.info())

input_data.describe()

object_attr = ['balancing_status', 'thermal_manager_mode', 'cycle', 'fast_charge']
for attr in object_attr:
    print(attr)
    print(input_data[attr].value_counts())

balancing_kvp = {'noBalancing' : 1, 'passiveBalancing' : 2, 'initialValue' : 3}
thermal_kvp = {'idle' : 1, 'activeHeating' : 2, 'passingCooling' : 3, 'thermalBalancing' : 4, 'initialValue' : 5, 'activeCooling' : 6}
cycle_kvp = {'charge' : 1, 'drive' : 2, 'storage' : 3}
fast_charge_kvp = {False : 0, True : 1}

input_data = input_data.replace({object_attr[0]: balancing_kvp})
input_data = input_data.replace({object_attr[1]: thermal_kvp})
input_data = input_data.replace({object_attr[2]: cycle_kvp})
input_data = input_data.replace({object_attr[3]: fast_charge_kvp})

input_data = input_data.drop(columns=['recorded_time'])
input_data.head()

#input_data2 = input_data[np.isfinite(input_data).all(1)]
#input_data.shape()
#input_data2.info()
input_data.replace([np.inf, -np.inf], np.nan)

input_data.round(5)
input_data.describe()
imputer.fit_transform(input_data)

input_data.isnull().sum().sum()
#input_data['imbalance_percent'].value_counts()

X_train, X_test, y_train, y_test = train_test_split(input_data, output_data, test_size=0.2, random_state=0)

from sklearn.impute import SimpleImputer 
imputer = SimpleImputer(missing_values=np.nan, strategy='mean')
#X_train.fillna(0)
#y_train.fillna(0)
#X_test.fillna(0)
#y_test.fillna(0)
imputer.fit_transform(X_train)

from sklearn.tree import DecisionTreeRegressor

reg_tree = DecisionTreeRegressor()

reg_tree.fit(X_train, y_train)
reg_tree_pred = reg_tree.predict(X_test)
'''
plt.figure(figsize=(10, 6))
plt.plot(X_test, f(X_test), "b")
plt.scatter(X_train, y_train, c="b", s=20)
plt.plot(X_test, reg_tree_pred, "g", lw=2)
plt.xlim([-5, 5])
plt.title("Decision tree regressor, MSE = %.2f" % (np.sum((y_test - reg_tree_pred) ** 2) / n_test))
plt.show()
'''

regressor = LinearRegression()  
regressor.fit(X_train, y_train)

sns.countplot(bat_data['powermode'])

X_train, X_test, y_train, y_test = train_test_split(input_data, output_data, test_size=0.2, random_state=0)

